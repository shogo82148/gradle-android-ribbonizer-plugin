/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.shogo82148.ribbonizer.plugin

import com.android.build.api.artifact.MultipleArtifact
import com.android.build.api.artifact.SingleArtifact
import com.android.build.api.variant.ApplicationAndroidComponentsExtension
import com.android.build.api.variant.ApplicationVariant
import com.android.build.api.variant.VariantOutputConfiguration.OutputType
import com.shogo82148.ribbonizer.FilterBuilder
import com.shogo82148.ribbonizer.GreenRibbonBuilder
import java.io.File
import java.util.Locale
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.file.Directory
import org.gradle.api.tasks.TaskProvider

class RibbonizerPlugin: Plugin<Project> {
    override fun apply(project: Project) {
        // add RibbonizerExtension
        project.extensions.add(RibbonizerExtension.NAME, RibbonizerExtension::class.java)

        // add Robbonize Tasks
        val androidComponents = project.extensions.findByType(ApplicationAndroidComponentsExtension::class.java)
            ?: throw Exception("Not an Android application; you forget `apply plugin: 'com.android.application`?")
        val extension = project.extensions.findByType(RibbonizerExtension::class.java)!!

        val tasks = mutableListOf<TaskProvider<RibbonizerTask>>()

        // collect information about variant beforeVariants.
        val objects = project.objects
        androidComponents.beforeVariants { variant ->
            val variantExtension = objects.newInstance(VariantExtension::class.java)
            variantExtension.debuggable.set(variant.debuggable)
            variant.registerExtension(VariantExtension::class.java, variantExtension)
        }

        androidComponents.onVariants { variant ->
            val debuggable = variant.getExtension(VariantExtension::class.java)?.debuggable?.get() ?: true
            if (!debuggable && !extension.forcedVariantsNames.contains(variant.name)) {
               project.logger.info("[ribbonizer] skip ${variant.name} because it is not debuggable and not forced.")
               return@onVariants
            }

            var filterBuilders = extension.filterBuilders
            if (filterBuilders.isEmpty()) {
                filterBuilders = listOf(GreenRibbonBuilder() as FilterBuilder)
            }

            val mainOutput = variant.outputs.single { it.outputType == OutputType.SINGLE }
            val myVariant = Variant(
                debuggable = debuggable,
                name = variant.name,
                buildType = variant.buildType ?: "",
                versionCode = mainOutput.versionCode.get() ?: 0,
                versionName = mainOutput.versionName.get() ?: "",
                flavorName = variant.flavorName ?: ""
            )

            val capitalizedName = capitalize(variant.name)
            val name = "${RibbonizerTask.NAME}${capitalizedName}"
            val task = project.tasks.register(name, RibbonizerTask::class.java) {
                it.manifest.set(variant.artifacts.get(SingleArtifact.MERGED_MANIFEST))
                it.assets.set(variant.sources.assets?.all)
                it.variant.set(myVariant)
                it.iconNames.set(extension.iconNames)
                it.filterBuilders.set(filterBuilders)
            }
            variant.sources.assets?.addGeneratedSourceDirectory(task, RibbonizerTask::outputDir)
            tasks.add(task)

            val generatedResources =
                project.getTasksByName("generate${capitalize(variant.name)}Resources", false)
            generatedResources.forEach {
                it.dependsOn(task)
            }
        }
        project.task(mapOf("dependsOn" to tasks), RibbonizerTask.NAME)
    }
}

fun capitalize(string: String): String {
    return string.replaceFirstChar {
        it.uppercase()
    }
}

fun getGeneratedResDir(project: Project, variant: ApplicationVariant): File {
    return File(project.buildDir, "generated/ribbonizer/res/${variant.name}")
}
